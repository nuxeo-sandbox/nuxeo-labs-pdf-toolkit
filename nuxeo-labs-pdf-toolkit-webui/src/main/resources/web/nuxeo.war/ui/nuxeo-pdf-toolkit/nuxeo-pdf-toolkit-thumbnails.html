<!--
`nuxeo-pdf-toolkit-thumbnails`
Generic thumbnails grid with selection + drag & drop.
Parent passes an array of image sources (URLs or data URLs).
-->
<dom-module id="nuxeo-pdf-toolkit-thumbnails">
  <template>
    <style>
      :host {
        display: block;
      }

      .loading {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 120px;
      }

      .thumbnails-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 16px;
        padding: 8px;
      }

      .page-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background-color: #fff;
        cursor: pointer;
        transition: box-shadow 0.2s ease, border-color 0.2s ease,
          background-color 0.2s ease;
        position: relative;
      }

      .page-item:hover {
        border-color: #999;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .page-item.selected {
        border-color: var(--nuxeo-primary-color, #0066ff);
        background-color: #f0f7ff;
        box-shadow: 0 4px 8px rgba(0,102,255,0.2);
      }

      .page-item.dragging {
        opacity: 0.5;
      }

      .page-item.drag-over-before::before,
      .page-item.drag-over-after::after {
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        width: 4px;
        background-color: var(--nuxeo-primary-color, #0066ff);
        border-radius: 2px;
      }

      .page-item.drag-over-before::before {
        left: -8px;
      }

      .page-item.drag-over-after::after {
        right: -8px;
      }

      .page-thumbnail {
        width: 100%;
        max-width: 120px;
        height: auto;
        border: 1px solid #ccc;
        border-radius: 2px;
      }

      .page-number {
        margin-top: 8px;
        font-weight: 500;
        font-size: 14px;
        color: #333;
      }
    </style>

    <template is="dom-if" if="[[loading]]">
      <div class="loading">
        <paper-spinner active></paper-spinner>
      </div>
    </template>

    <template is="dom-if" if="[[!loading]]">
      <div class="thumbnails-container">
        <template is="dom-repeat" items="[[pages]]" as="page">
          <div class$="page-item [[_getSelectedClass(page.selected)]]"
               draggable="true"
               data-index$="[[index]]"
               on-click="_togglePageSelection"
               on-dblclick="_onPageDblClick"
               on-dragstart="_onDragStart"
               on-dragover="_onDragOver"
               on-dragleave="_onDragLeave"
               on-drop="_onDrop"
               on-dragend="_onDragEnd">
            <img class="page-thumbnail"
                 src="[[page.image]]"
                 alt$="Page [[_computePageNumber(index, page.originalPageNumber)]]">
            <span class="page-number">[[_computePageNumber(index, page.originalPageNumber)]]</span>
          </div>
        </template>
      </div>
    </template>
  </template>

  <script>
    Polymer({
      is: 'nuxeo-pdf-toolkit-thumbnails',

      properties: {
        // Array of image sources (URLs or data URLs)
        // provided by the parent.
        sources: {
          type: Array,
          value: function() { return []; },
          observer: '_sourcesChanged'
        },

        // Internal representation of pages, used for selection + DnD.
        pages: {
          type: Array,
          value: function() { return []; }
        },

        // Show a spinner while parent is loading thumbnails
        loading: {
          type: Boolean,
          value: false
        },

        // true if at least one page is selected
        hasSelection: {
          type: Boolean,
          value: false,
          notify: true
        },

        // true if current order differs from original order
        hasReordered: {
          type: Boolean,
          value: false,
          notify: true
        },

        // ==============================
        // Private properties
        // ==============================
        _draggedIndex: {
          type: Number,
          value: -1
        },

        _originalOrder: {
          type: Array,
          value: function() { return []; }
        },

        _lastSelectedIndex: {
          type: Number,
          value: -1
        },

        _autoScrollInterval: {
          type: Object,
          value: null
        },

        _dragMouseY: {
          type: Number,
          value: 0
        }
      },

      // --- Public API for parent ---

      reset: function() {
        this.set('pages', []);
        this.set('_originalOrder', []);
        this._lastSelectedIndex = -1;
        this._draggedIndex = -1;
        this._dragMouseY = 0;
        this._stopAutoScroll();
        this.set('hasSelection', false);
        this.set('hasReordered', false);
      },

      /**
       * Return selected pages as a range string, e.g. "1,3-5".
       */
      getSelectedPageRanges: function() {
        return this._getSelectedPageRanges();
      },

      /**
       * Return current order as an array of original indices, e.g. [2,1,3,...].
       */
      getNewPageOrder: function() {
        if (!this.pages || !this.pages.length) {
          return [];
        }
        return this.pages.map(function(page) {
          return page.originalPageNumber;
        });
      },

      // --- React to sources changes ---

      _sourcesChanged: function(sources) {
        this.reset();
        if (!sources || !sources.length) {
          return;
        }

        var pagesData = sources.map(function(src, index) {
          return {
            image: src,
            selected: false,
            originalPageNumber: index + 1
          };
        });

        this.set('pages', pagesData);
        this.set('_originalOrder', pagesData.map(function(p) { return p.originalPageNumber; }));
        this.set('hasReordered', false);
        this.set('hasSelection', false);
      },

      // --- Selection logic ---

      _togglePageSelection: function(e) {
        var index = e.model.index;
        var isMetaKey = e.metaKey || e.ctrlKey; // Cmd on Mac / Ctrl on Windows
        var isShiftKey = e.shiftKey;

        if (isShiftKey && this._lastSelectedIndex >= 0) {
          // Range selection
          var start = Math.min(this._lastSelectedIndex, index);
          var end = Math.max(this._lastSelectedIndex, index);
          this.pages.forEach(function(page, i) {
            if (i >= start && i <= end) {
              this.set('pages.' + i + '.selected', true);
            }
          }.bind(this));
        } else if (isMetaKey) {
          // Toggle single
          this.set('pages.' + index + '.selected', !this.pages[index].selected);
          this._lastSelectedIndex = index;
        } else {
          // Single selection
          this.pages.forEach(function(page, i) {
            this.set('pages.' + i + '.selected', i === index);
          }.bind(this));
          this._lastSelectedIndex = index;
        }

        this.set('hasSelection', this._computeHasSelection());
      },

      _computePageNumber: function(index, originalPageNumber) {
        var pageNumber = index + 1;

        if (pageNumber !== originalPageNumber) {
          return pageNumber + ' (' + originalPageNumber + ')';
        }

        return pageNumber;
      },

      _getSelectedClass: function(selected) {
        return selected ? 'selected' : '';
      },

      _computeHasSelection: function() {
        return this.pages && this.pages.some(function(page) {
          return page.selected;
        });
      },

      _getSelectedPageRanges: function() {
        var selectedIndices = [];
        this.pages.forEach(function(page, index) {
          if (page.selected) {
            selectedIndices.push(index + 1);
          }
        });

        if (!selectedIndices.length) {
          return '';
        }

        var ranges = [];
        var start = selectedIndices[0];
        var prev = selectedIndices[0];

        for (var i = 1; i <= selectedIndices.length; i++) {
          if (i === selectedIndices.length || selectedIndices[i] !== prev + 1) {
            if (start === prev) {
              ranges.push(start.toString());
            } else {
              ranges.push(start + '-' + prev);
            }
            if (i < selectedIndices.length) {
              start = selectedIndices[i];
              prev = selectedIndices[i];
            }
          } else {
            prev = selectedIndices[i];
          }
        }

        return ranges.join(',');
      },

      // --- Double-click â†’ preview ---
      _onPageDblClick: function(e) {
        var index = e.model.index;
        var page = this.pages[index];
        if (!page) {
          return;
        }

        this.fire('page-preview', {
          pageNum: page.originalPageNumber
        });
      },

      // --- Drag & drop + auto-scroll ---

      _onDragStart: function(e) {
        this._draggedIndex = parseInt(e.currentTarget.dataset.index);
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/plain', ''); // needed for Firefox
        this._startAutoScroll();
      },

      _onDragOver: function(e) {
        if (e.preventDefault) {
          e.preventDefault();
        }
        e.dataTransfer.dropEffect = 'move';

        this._dragMouseY = e.clientY;

        var rect = e.currentTarget.getBoundingClientRect();
        var mouseX = e.clientX;
        var itemCenterX = rect.left + rect.width / 2;

        e.currentTarget.classList.remove('drag-over-before', 'drag-over-after');
        if (mouseX < itemCenterX) {
          e.currentTarget.classList.add('drag-over-before');
        } else {
          e.currentTarget.classList.add('drag-over-after');
        }

        return false;
      },

      _onDragLeave: function(e) {
        e.currentTarget.classList.remove('drag-over-before', 'drag-over-after');
      },

      _onDrop: function(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        }
        e.currentTarget.classList.remove('drag-over-before', 'drag-over-after');

        var dropIndex = parseInt(e.currentTarget.dataset.index);
        if (this._draggedIndex !== dropIndex && this._draggedIndex >= 0) {
          var rect = e.currentTarget.getBoundingClientRect();
          var mouseX = e.clientX;
          var itemCenterX = rect.left + rect.width / 2;

          var insertIndex = dropIndex;
          if (mouseX >= itemCenterX) {
            insertIndex = dropIndex + 1;
          }
          if (this._draggedIndex < insertIndex) {
            insertIndex--;
          }

          var draggedPage = this.pages[this._draggedIndex];
          var newPages = this.pages.slice();
          newPages.splice(this._draggedIndex, 1);
          newPages.splice(insertIndex, 0, draggedPage);

          var currentOrder = newPages.map(function(p) { return p.originalPageNumber; });
          var hasChanged = !this._arraysEqual(currentOrder, this._originalOrder);

          this.set('pages', newPages);
          this.set('hasReordered', hasChanged);
        }

        return false;
      },

      _onDragEnd: function(e) {
        e.currentTarget.classList.remove('dragging');
        this._draggedIndex = -1;
        this._stopAutoScroll();
        var items = this.shadowRoot.querySelectorAll('.page-item');
        items.forEach(function(item) {
          item.classList.remove('drag-over-before', 'drag-over-after');
        });
      },

      _startAutoScroll: function() {
        this._stopAutoScroll();
        this._autoScrollInterval = setInterval(function() {
          this._performAutoScroll();
        }.bind(this), 50);
      },

      _stopAutoScroll: function() {
        if (this._autoScrollInterval) {
          clearInterval(this._autoScrollInterval);
          this._autoScrollInterval = null;
        }
      },

      _getScrollContainer: function() {
        // Walk up from this element to find the surrounding .dialog-content
        var node = this.parentNode;
        while (node) {
          if (node.classList && node.classList.contains('dialog-content')) {
            return node;
          }
          node = node.parentNode || node.host;
        }
        return null;
      },

      _performAutoScroll: function() {
        if (!this._dragMouseY) {
          return;
        }

        var dialogContent = this._getScrollContainer();
        if (!dialogContent) {
          return;
        }

        var rect = dialogContent.getBoundingClientRect();
        var scrollThreshold = 100; // px from edge to trigger
        var scrollSpeed = 20;      // px per tick

        if (this._dragMouseY < rect.top + scrollThreshold) {
          dialogContent.scrollTop -= scrollSpeed;
        } else if (this._dragMouseY > rect.bottom - scrollThreshold) {
          dialogContent.scrollTop += scrollSpeed;
        }
      },

      _arraysEqual: function(a, b) {
        if (!a || !b || a.length !== b.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
    });
  </script>
</dom-module>